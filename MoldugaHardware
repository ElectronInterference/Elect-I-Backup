/* Copyright (c) 2017 FIRST. All rights reserved.*/
package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.Servo;
import org.firstinspires.ftc.robotcore.external.ClassFactory;
import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.ElapsedTime;
import java.util.List;
import org.firstinspires.ftc.robotcore.external.Func;
import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.Position;
import org.firstinspires.ftc.robotcore.external.navigation.Velocity;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;
import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;

/* This is the hardware program for our 2018-2019 Rover Ruckus robot, Molduga.
*
*This is the progam that declares all of our hardware, and has several
*useful functions that could be used by any opmode.
*
* --HARDWARE DEVICES--
*
*DEFINITE:
*
*leftrearDrive -- REV HD 40:1 hex motor (drive train)
*leftfrontDrive -- REV HD 40:1 hex motor (drive train)
*rightrearDrive -- REV HD 40:1 hex motor (drive train)
*rightfrontDrive -- REV HD 40:1 hex motor (drive train)
*lift -- Tetrix TorqueNado (lift)
*mineralLift -- cr servo (mineral lift)
*
*Releaser -- REV servo (team marker deployment)
*
*Gyro -- the internal gyro in the REV hub
*
*
*SUBJECT TO CHANGE:
*
*
*
*PLANNED:
*
*
*
* --FUNCTIONS--
*
*StopDrive -- stops all drive motors
*StopAll -- stops all motors and servos
*LiftUp -- raise the lift
*LiftDown -- lower the lift
*DriveForward -- drive forward(inches)
*DriveBackward -- drive backward(inches)
*DriveLeft -- strafe left(inches)
*DriveRight -- strafe right(inches)
*Wait -- wait(millis)
*ReleaseMarker -- move Releaser servo up
*HoldMarker -- move Releaser servo down
*TurnDegrees -- turn a number of degrees(relative to the starting position)
*DetectCheeseBlock -- Detect which position the cheeseblock is in
*/




public class MoldugaHardware {
    
    
    //public opMode members
    public DcMotor  leftrearDrive   = null;
    public DcMotor  rightrearDrive  = null;
    public DcMotor  leftfrontDrive     = null;
    public DcMotor  rightfrontDrive    = null;
    public DcMotor  lift    = null;
    public Servo    Releaser   = null;
    public CRServo  mineralLift = null;
    public BNO055IMU imu;
    
    // the files for detecting the minerals
    public static final String TFOD_MODEL_ASSET = "RoverRuckus.tflite";
    public static final String LABEL_GOLD_MINERAL = "Gold Mineral";
    public static final String LABEL_SILVER_MINERAL = "Silver Mineral";
    
    private static final String VUFORIA_KEY = "ARZ9jK3/////AAABmUUaXNvhrkixjdVoQTApe8pKkOSgBAzrh4w49x76evPSBhJPD9ODNLDRoctaDi+4NXihmNZvGN0xSQfWqVc43szbn4ZQzKGAqkQo/GgHbVqADcuwbyEfGYnm7bC9FbbWQmik6swfX1uQo//lK+zHLote6GO5p63tORZ9VWZQjiBMMU8oqKWZmNmLGxsOz/8Xw1mrZodbIu7hUMkjEVbgxhONut4XPReM2Q2sipOZKy0YxSiWBTaXNvLi2egkhXAFL8F9DOatuzQyZdobssqwbDQ7emn1EP+OqgqbzJdV9C0YibdGb2+Sxzeppy+wUYAqBiCs7eHGVLuzqq6IPHxSTtvNYC5+JhWWJNx1Qyz7p1zm";

    // stores an instance of the vuforia localizer engine
    public VuforiaLocalizer vuforia;

    // stores an instance of the TensorFlow Object Detector engine
    public TFObjectDetector tfod;
    
    //The variables for our robot's wheels. 
    static final double     COUNTS_PER_MOTOR_REV    = 1440 ;    // eg: TETRIX Motor Encoder
    static final double     DRIVE_GEAR_REDUCTION    = 1 ;     // This is < 1.0 if geared UP
    static final double     WHEEL_DIAMETER_INCHES   = 6.0 ;     // For figuring circumference
    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
                                                      (WHEEL_DIAMETER_INCHES * 3.1415);
    
    //local opMode members
    HardwareMap hwMap           =  null;
    private ElapsedTime period  = new ElapsedTime();

    /* Constructor */
    public MoldugaHardware(){

    }

    /* Initialize standard Hardware interfaces */
    public void init(HardwareMap ahwMap) {
        // Save reference to Hardware map
        hwMap = ahwMap;

        //define and initialize motors
        leftfrontDrive  = hwMap.get(DcMotor.class, "leftfrontDrive");
        rightfrontDrive = hwMap.get(DcMotor.class, "rightfrontDrive");
        leftrearDrive   = hwMap.get(DcMotor.class, "leftrearDrive");
        rightrearDrive  = hwMap.get(DcMotor.class, "rightrearDrive");
        lift            = hwMap.get(DcMotor.class, "lift");
        
        leftrearDrive.setDirection(DcMotor.Direction.FORWARD); 
        rightrearDrive.setDirection(DcMotor.Direction.REVERSE);
        leftfrontDrive.setDirection(DcMotor.Direction.FORWARD); 
        rightfrontDrive.setDirection(DcMotor.Direction.REVERSE);

        // Set all motors to zero power
        leftrearDrive.setPower(0);
        leftfrontDrive.setPower(0);
        rightrearDrive.setPower(0);
        rightfrontDrive.setPower(0);
        lift.setPower(0);
        
        // Set all motors to run without encoders.
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        leftrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        // Define and initialize servos.
        Releaser  = hwMap.get(Servo.class, "Releaser");
        
        //Define and initialize cr servos.
        mineralLift = hwMap.get(CRServo.class, "mineralLift");
        
        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();

        parameters.mode                = BNO055IMU.SensorMode.IMU;
        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;
        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
        parameters.loggingEnabled      = false;

        // Retrieve and initialize the IMU. We expect the IMU to be attached to an I2C port
        // on a Core Device Interface Module, configured to be a sensor of type "AdaFruit IMU",
        // and named "imu".
        imu = hwMap.get(BNO055IMU.class, "imu");

        imu.initialize(parameters);
        
        //initialize Vuforia
        initVuforia();
        initTfod();
        tfod.activate();

    }
    
    /*Functions*/
    
    //wait for a number of seconds
    public void wait(int delay) {
        try {
            Thread.sleep(delay);
        }catch(Exception e) {
        }
    }
    
    //stop all drive motors
    public void stopDrive() {
        leftrearDrive.setPower(0);
        leftfrontDrive.setPower(0);
        rightrearDrive.setPower(0);
        rightfrontDrive.setPower(0);
    }
    
    //stop all motors
    public void stopAll() {
        leftrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        leftrearDrive.setPower(0);
        leftfrontDrive.setPower(0);
        rightrearDrive.setPower(0);
        rightfrontDrive.setPower(0);
        lift.setPower(0);
    }
    
    public void driveForward(double power, int targetDistance) {
        leftrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        leftrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        leftrearDrive.setTargetPosition((int)(COUNTS_PER_INCH * targetDistance));
        rightrearDrive.setTargetPosition((int)(COUNTS_PER_INCH * targetDistance));
        leftfrontDrive.setTargetPosition((int)(COUNTS_PER_INCH * targetDistance));
        rightfrontDrive.setTargetPosition((int)(COUNTS_PER_INCH * targetDistance));
        
        leftfrontDrive.setPower(Math.abs(power * 0.7));  //TODO: THIS NEEDS TO BE FIXED
        rightfrontDrive.setPower(Math.abs(power));
        leftrearDrive.setPower(Math.abs(power));
        rightrearDrive.setPower(Math.abs(power));
        while(leftfrontDrive.isBusy() && rightfrontDrive.isBusy() && leftrearDrive.isBusy() && rightrearDrive.isBusy()) {
            //Wait for one of the motors to reach its target
        }
        stopAll();
        
    }
    
    public void driveBackward(double power, double targetDistance) {
        leftrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftrearDrive.setTargetPosition((int)(-COUNTS_PER_INCH * targetDistance));
        rightrearDrive.setTargetPosition((int)(-COUNTS_PER_INCH * targetDistance));
        leftfrontDrive.setTargetPosition((int)(-COUNTS_PER_INCH * targetDistance));
        rightfrontDrive.setTargetPosition((int)(-COUNTS_PER_INCH * targetDistance));
        leftfrontDrive.setPower(Math.abs(power * 0.7));
        rightfrontDrive.setPower(Math.abs(power));
        leftrearDrive.setPower(Math.abs(power));
        rightrearDrive.setPower(Math.abs(power));
        while(leftfrontDrive.isBusy() && rightfrontDrive.isBusy() && leftrearDrive.isBusy() && rightrearDrive.isBusy()) {
            //Loop body can be empty
        }
        stopAll(); 
    }
    
    public void markerHold() {
        Releaser.setPosition(0.32);
    }
    
    public void markerRelease() {
        Releaser.setPosition(-0.2);
    }
    
    public void liftUp() {
        lift.setPower(-0.5);
        wait(3900);
        lift.setPower(0);
    }
    
    public void liftDown() {
        lift.setPower(0.8);
        wait(650);
        lift.setPower(0);
    }
    
    public void driveLeft(double power, double targetDistance) {
        leftrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        int target = (int)(COUNTS_PER_INCH * targetDistance);
        leftrearDrive.setTargetPosition(target);
        rightrearDrive.setTargetPosition(-target);
        leftfrontDrive.setTargetPosition(-target);
        rightfrontDrive.setTargetPosition(target);
        leftfrontDrive.setPower(Math.abs(power * 0.7));
        rightfrontDrive.setPower(Math.abs(power));
        leftrearDrive.setPower(Math.abs(power));
        rightrearDrive.setPower(Math.abs(power));
        while(leftfrontDrive.isBusy() && rightfrontDrive.isBusy() && leftrearDrive.isBusy() && rightrearDrive.isBusy()) {
            //Loop body can be empty
        }
        stopAll();
    }
    
    public void driveRight(double power, double targetDistance) {
        leftrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightrearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftfrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        int target = (int)(COUNTS_PER_INCH * targetDistance);
        leftrearDrive.setTargetPosition(-target);
        rightrearDrive.setTargetPosition(target);
        leftfrontDrive.setTargetPosition(target);
        rightfrontDrive.setTargetPosition(-target);
        leftfrontDrive.setPower(Math.abs(power * 0.7));
        rightfrontDrive.setPower(Math.abs(power));
        leftrearDrive.setPower(Math.abs(power));
        rightrearDrive.setPower(Math.abs(power));
        while(leftfrontDrive.isBusy() && rightfrontDrive.isBusy() && leftrearDrive.isBusy() && rightrearDrive.isBusy()) {
            //Loop body can be empty
        }
        stopDrive();
    }
    
    
    
    //Turn a desired number of degrees
    public void turnDegrees(int target) {
        
        //try to turn four times. This improves precision
        
        for(int i = 0; i < 4; i ++) {
            
            //reset the encoders
            leftrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            rightrearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            rightfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            leftfrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            rightfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            leftrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            rightrearDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            leftfrontDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            
            //find our current heading
            float currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;
            //if we need to turn left...
            if(currentAngle > target) {
                
                //turn left
                leftrearDrive.setPower(-0.3);
                leftfrontDrive.setPower(-0.3);
                rightrearDrive.setPower(0.3);
                rightfrontDrive.setPower(0.3);
                
                //wait until the robot has turned far enough
                while (currentAngle > target + 5) {
                    currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;
                }
            //if we need to turn right...
            }else if(currentAngle < target - 5) {
                //turn right
                leftrearDrive.setPower(0.3);
                leftfrontDrive.setPower(0.3);
                rightrearDrive.setPower(-0.3);
                rightfrontDrive.setPower(-0.3);
                //wait until the robot has turned far enough
                while (currentAngle < target) {
                    currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;
                }
            //if we do not know which way to turn, just stop
            }else{
                stopAll();
            }
            //stop after we have finished
            stopAll();
        }
    }
    
    //functions for Vuforia
        /**
     * Initialize the Vuforia localization engine.
     */
    public void initVuforia() {
        /*
         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.
         */
        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();

        parameters.vuforiaLicenseKey = VUFORIA_KEY;
        parameters.cameraDirection = CameraDirection.BACK;

        //  Instantiate the Vuforia engine
        vuforia = ClassFactory.getInstance().createVuforia(parameters);

        // Loading trackables is not necessary for the Tensor Flow Object Detection engine.
    }



    /**
     * Initialize the Tensor Flow Object Detection engine.
     */
    private void initTfod() {
        int tfodMonitorViewId = hwMap.appContext.getResources().getIdentifier(
            "tfodMonitorViewId", "id", hwMap.appContext.getPackageName());
        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);
        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);
        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_GOLD_MINERAL, LABEL_SILVER_MINERAL);
    }
    
    public int detectCheeseBlock() {
        if (tfod != null) {
            // getUpdatedRecognitions() will return null if no new information is available since
            // the last time that call was made.
            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();
            if (updatedRecognitions != null) {
                //telemetry.addData("# Object Detected", updatedRecognitions.size());
                if (updatedRecognitions.size() == 3) {
                    int goldMineralX = -1;
                    int silverMineral1X = -1;
                    int silverMineral2X = -1;
                    for (Recognition recognition : updatedRecognitions) {
                        if (recognition.getLabel().equals(LABEL_GOLD_MINERAL)) {
                            goldMineralX = (int) recognition.getLeft();
                        } else if (silverMineral1X == -1) {
                            silverMineral1X = (int) recognition.getLeft();
                        } else {
                            silverMineral2X = (int) recognition.getLeft();
                        }
                    }
                    if (goldMineralX != -1 && silverMineral1X != -1 && silverMineral2X != -1) {
                        if (goldMineralX < silverMineral1X && goldMineralX < silverMineral2X) {
                            return 0;
                        } else if (goldMineralX > silverMineral1X && goldMineralX < silverMineral2X) {
                            return 1;
                        } else if(goldMineralX > silverMineral1X && goldMineralX > silverMineral2X) {
                            return 2;
                        }
                    } else {
                        return -4;
                    }
                }else {
                    return -3;
                }
            } else {
                
                return -2;
            }
        }else{
          return -1;
        }
        return -5;
    }
    
}

