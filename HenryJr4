/* Copyright (c) 2017 FIRST. All rights reserved. */


package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import java.util.Timer;
import java.util.TimerTask;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;
import org.firstinspires.ftc.teamcode.MoldugaHardware;
import java.util.List;
import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;
import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;



/**
 * This is our autonomous program, starting from the depot
 */
@Autonomous(name="CraterAuto", group="Linear Opmode")

public class HenryJr4 extends LinearOpMode {

    //access our hardware program
    MoldugaHardware robot   = new MoldugaHardware();

    //create a timer to send whether the program is stopped to the hardware class
    Timer timer = new Timer("Check For Stop");
    TimerTask checkForStop = new TimerTask() {
        @Override
        public void run() {
            //If needed, change a variable in MoldugaHardware that stores whether stop is requested
            robot.isStopRequested = isStopRequested();
            
            //Stop this timer if the program is stopped.
            if(robot.isStopRequested) {
                timer.cancel();
            }
        }
    };
    
    //Wait 50 millis between each loop of the timer and don't delay anything besides that.
    long timerPeriod = 50L;
    long delay = 0L;
    
    
    
    @Override
    public void runOpMode() {
        
        //Schedule a time to tell MoldugaHardware whether the program is stopped
        timer.schedule(checkForStop, delay, timerPeriod );
        
        //Create a boolean so that our program is only run once
        boolean done = false;
            
        //use our hardwaremap program
        robot.init(hardwareMap);
        
        //tell the drivers we have initialized
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        
        //wait for the program to start
        waitForStart();
        
        while(opModeIsActive()) {
            
            //If we aren't done, do all of the functions below in order
            if(!done) {
                Land();
                KnockOffCheeseblock();
                navigateToDepot();
                DeployMarker();
                NavigateToCrater();
                
                //stop the timer and tell the loop we are done
                timer.cancel();
                done = true;
            }
        }
    }
    
    //land and reorient ourselves
     public void Land(){
         //Move the lift up
        //robot.liftUp();
        //strafe off of the latch
        robot.driveRight(1,6);
        //turn away from the lander
        robot.turnDegrees(35);
    }
    public void KnockOffCheeseblock(){
        
        //store variables for finding the gold mineral
        int location = -10;
        int minX = 210;
        int maxX = 290;
        int turnInc = 20;
        
        //start turning
        robot.leftfrontDrive.setPower(-0.2);
        robot.leftrearDrive.setPower(-0.2);
        robot.rightfrontDrive.setPower(0.2);
        robot.rightrearDrive.setPower(0.2);
        
        //loop while we have not found the gold mineral or have missed the cheeseblock(turned to far)
        while(!(location > minX && location < maxX )&&robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle > -35 ) {
            location = robot.findCheeseblockX();
            //turnInc = turnInc+5;
            
            //if the location is positive, send th
            if (location >= 0) {
                telemetry.addData ("location", location);
                telemetry.update(); 
            }
            
           robot.wait(10);
        }
        robot.stopDrive();
        //telemetry.addData ("status", "Found");
        telemetry.update();   
        //robot drives and knocks off the cheeseblock once it is found 
        robot.driveForward(.6,32);
        robot.wait(250);
        //backs up to the original starting spot
        robot.driveBackward(.6,31);
        //sets gyro back to zero
        robot.turnDegrees(0);
    }
    
    //Go to our alliance's depot
    public void navigateToDepot() {
        //Drive away from the crater
        robot.driveForward(0.7,10);
        //Turn left towards the Depot(but not all the way or we would hit the lander's legs)
        robot.turnDegrees(85);
        //Drive between the crater and the lander
        robot.driveForward(0.9,47);
        //Turn towards the depot
        robot.turnDegrees(130);
        //Go into the depot
        robot.driveForward(0.9,36);
    }
    
    //Deploy our team marker
    public void DeployMarker() {
        //Turn so our team marker can only fall into the depot
        robot.turnDegrees(0);
        //release the marker
        robot.markerRelease();  
        //wait until the marker has definitely fallen
        robot.wait(500);
    }
    
    //Drive into the crater
    public void NavigateToCrater(){
        
        //Turn towards the crater
        robot.turnDegrees(-40);
        //Drive into the crater
        robot.driveForward(1,102);

    }
    

}
    

      
